//------------------------------------------------------------------------------
// <auto-generated>
//     Este código se generó mediante una herramienta.
//     Los cambios del archivo se perderán si se regenera el código.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Linq;
using System.Text;

public class TrieDictionary : ITrieDictionary
{
	public virtual TrieNode _rootNode
	{
		get;
		set;
	}

	public virtual ITrieNode ITrieNode
	{
		get;
		set;
	}

	public IEnumerator GetEnumerator()
	{
        return new TrieDictionaryEnumerator(_rootNode);
	}

	public int insert(string word)
	{
        ITrieNode actualNode = _rootNode;
        foreach (char c in word) {
            if (actualNode.value(c) == null){
                //Si la letra no existe se crea la nueva rama
                actualNode.asign(c, new TrieNode(actualNode));
                actualNode = actualNode.value(c);
            }
            else {
                //Si sí existe se sigue revisando
                actualNode = actualNode.value(c);
            }
        }
        return actualNode.terminate();//Retorna si ya la palabra existía
	}

	public int remove(string word)
	{
        /*ITrieNode actualNode = _rootNode;
        foreach (char c in word)
        {
            if (actualNode.value(c) == null)
            {
                //Si la letra no existe no está
                break;
            }
            else
            {
                //Si sí existe se sigue revisando
                actualNode = actualNode.value(c);
            }
        }
        if (0 == actualNode.isTerminated()) return 0; //Si no está no se puede remover

        while (actualNode.getParent() != null) {
            if (actualNode.getChildrenCount() <= 0) { }
        }*/

        return removeAux(word, _rootNode);


    }

    private int removeAux(string word, ITrieNode node) {//TODO: FALTA PROBAR
        if (word == "")
        {               //Caso base recursivo
            if (!Convert.ToBoolean(node.isTerminated()))
                return 0;
        }
        else if (Convert.ToBoolean(node.isTerminated())) {//TODO: Falta verificar que ya se haya revisado toda la palabra
            return 0;
        }
        else
        {          //Caso trivial
            removeAux(word.Substring(1), node.value(word[0]));
        }

        //Rollback
        if (node.getChildrenCount() < 2)
        {
            node.asign(word[0], null);
            return 1;
        }
        else return 0;

    }

	public virtual void print()
	{
		throw new System.NotImplementedException();
	}

	public int search(string word)
	{
        ITrieNode actualNode = _rootNode;
        foreach (char c in word)
        {
            if (actualNode.value(c) == null)
            {
                //Si la letra no existe no está
                break;
            }
            else
            {
                //Si sí existe se sigue revisando
                actualNode = actualNode.value(c);
            }
        }
        return actualNode.isTerminated();
    }

}

